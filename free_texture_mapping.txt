
                   ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
                   і Free Direction Texture Mapping і
                   АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ

The following article was posted by Hannu Helminen (dm@stekt.oulu.fi) to
comp.graphics.algorithms (article 4061). It has been included in the PC-GPE
with his permission.

ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД

初めに原則から見ていきましょう。DOOMでは、壁を描画する方法は単純です。
壁を垂直に分け、それから壁の始まりと終わり（AとB）、それに対応するテクスチャ座標を計算します。

Wall:      Texture:
 \            Y
  \B       \/\^\/\/\
  ^\       /\/./\/\/
  . \      \/\.\/\/\
  . /      /\/./\/\/
  ./          X
  /A
 /

次に、高度に最適化されたループを実行するだけです。
垂直線のピクセル、テクスチャから色を選択し、それを画面に配置して、テクスチャの次の位置に移動します。

床はもう少し複雑です。
今回は、フロアセグメントが水平線にマッピングされています。これは非常に単純です。
ただし、テクスチャスペースでは、同じ線がどの方向にもある可能性があるため、テクスチャに2D線があります。
このように：

Floor:     Texture:
    /\                Y
 A/...>\B       \/\/\.\/\
/        \      /\/\.\/\/
                \/./\/\/\
                /./\/\/\/
                X

これは古くて鈍いです。 ここで、新しくエキサイティングな部分について説明します。自由な向きの3空間でポリゴンを描画するとします。
上記のアイデアを少し考えて単純に拡張すると、表示座標にも自由方向の線を使用する必要があることがわかります。

自由な向きの平面を画面にマッピングすると、画面には常に1つの方向があり、z座標（距離）は同じままです。
DOOMの壁ではそれは垂直であり、床ではそれは水平です。しかし、すべての平面にそのような方向が1つあります。

一定のz座標が重要なのはなぜですか？
これらの線には、線に沿った一定の動きがテクスチャ空間での一定の動きに対応するという特別な特性があります。

上記の2つの段落は重要なものであるため、理解するまでもう一度読んでください。
残りは実装のみです。以下は私がそれをどのように行ったかについての簡単な説明です。

画面に描画しようとしているポリゴンごとに、次の手順を実行します。
平面方程式を見つけます。 それから、「constant-z」方向を導き出します。

ここでは、2つのケースを区別するのに役立ちます。
「constant-z」方向はより水平であるか、より垂直です。
それがより水平であると仮定します。 定数zの一次方程式はy = p * xのようになります。ここでは、-1 <= p <= 1です。

 ----
     ---   Example of a constant-z line
        ----
            ----

これで、座標系の変更が整いました。
xは以前と同じxですが、yはpの因数で「傾斜」しています。
これは、x軸が「傾斜」しているが、y軸は以前と同じであることを意味します。

次に、ポリゴンをこの座標系に変換します。
行ごとにスキャン変換しますが、これらの「傾斜した」（定数z）行に沿って変換します。

以下に示す三角形を描画しようとしていて、斜線が上に示したものであるとします。
したがって、次のようになります（アスキーアートが再び戻ってきました）。
テクスチャ内のパスも決定されます。

On the screen:     In texture (eg.):

 \-------            Y
 A...    -----/      /./\/\/\/
   \ ...     /       \/./\/\/\
    \   ..../        /\/./\/\/
     \     /B        \/\/./\/\
      \   /               X
       \ /
        X


したがって、三角形をレンダリングすると、結果は次のようになります。 数字はconstant-Zの値の線です。

 22221110
  3332221111000
   44333222211
    544433332
     5554444
      66555
       766
        7

Note: you should stack the constant-z lines just as shown in the picture.

Implementation notes: this will be a bit slower than DOOM floors, since the algorithm is a bit more complicated.
Another thing is that it will not be quite as cache-coherent.

If you are rendering big polygons (and have a large cache), it helps
to precalculate the pixels lying on the line, so you need not worry about
your Bresenham having to choose right pixels.
All you need to do is offset the line to right memory offset.

The inner loop of this machine could look something like this:

zbufpointer = zbufbase + offset;
pixelpointer = pixelbase + offset;

while (--count >= 0) {
  off = *precalculatedline++;
  if (z > zbufpoiner[off]) {
    zbufpointer[off] = z;
    pixelpointer[off] = texture(x,y);
  }
  x += dx;
  y += dy;
}

There is an error of about 0.5 pixel-lengths, since the pixels lying on
the constant-z lines are rounded to nearest pixels.

Another error can also be seen in the above picture, the line marked
with 0's has a small "gap" in it, what should we do with it?

Happy programming!

--dm
--

  Hannu    dm@stekt.oulu.fi  || You have been hacking too long when you
 Helminen dm@phoenix.oulu.fi || talk of people as users (or end-users)